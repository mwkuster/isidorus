;;+-----------------------------------------------------------------------------
;;+  Isidorus
;;+  (c) 2008-2010 Marc Kuester, Christoph Ludwig, Lukas Georgieff
;;+
;;+  Isidorus is freely distributable under the LLGPL license.
;;+  You can find a detailed description in trunk/docs/LLGPL-LICENSE.txt and
;;+  trunk/docs/LGPL-LICENSE.txt.
;;+-----------------------------------------------------------------------------


(in-package :jtm)

;TODO: write a generic outer method that evaluates the item_type,
;      version, parent, and prefixes and finally calls a special
;      function that creates a construct


(defun get-item (item-keyword jtm-list)
  (declare (Keyword item-keyword)
	   (List jtm-list))
  (rest (find item-keyword jtm-list :key #'first)))


(defun import-topic-stubs-from-jtm-lists (jtm-lists parents &key
					  (revision *TM-REVISION*) prefixes)
  "Creates and returns a list of topics.
   Note only the topic identifiers are imported and set in this function,
   entire topics are imported in merge-topics-from-jtm-lists."
  (declare (List jtm-lists parents prefixes)
	   (Integer revision))
  (map 'list #'(lambda(jtm-list)
		 (import-topic-stub-from-jtm-list
		  jtm-list parents :revision revision :prefixes prefixes))
       jtm-lists))


(defun import-topic-stub-from-jtm-list(jtm-list parents &key
				       (revision *TM-REVISION*) prefixes)
  "Creates and returns a topic object from the passed jtm
   list generated by json:decode-json-from-string.
   Note this function only sets the topic's identifiers."
  (declare (List jtm-list parents prefixes)
	   (Integer revision))
  (let* ((t-iis (import-identifiers-from-jtm-strings
		 (get-item :ITEM--IDENTIFIERS jtm-list)
		 :prefixes prefixes))
	 (t-psis (import-identifiers-from-jtm-strings
		  (get-item :SUBJECT--IDENTIFIERS jtm-list)
		  :prefixes prefixes :identifier-type-symbol 'd:PersistentIdC))
	 (t-sls (import-identifiers-from-jtm-strings
		 (get-item :SUBJECT--LOCATORS jtm-list)
		 :prefixes prefixes :identifier-type-symbol 'd:SubjectLocatorC))
	 (parent-references (get-item :PARENT jtm-list))
	 (local-parents
	  (if parents
	      parents
	      (when parent-references
		(get-items-from-jtm-references
		 parent-references :revision revision :prefixes prefixes)))))
    (unless local-parents
      (error (make-condition 'JTM-error :message (format nil "From import-topic-from-jtm-string(): the JTM topic ~a must have at least one parent set in its members." jtm-list))))
    (unless (append t-iis t-sls t-psis)
      (error (make-condition 'JTM-error :message (format nil "From import-topic-from-jtm-string(): the JTM topic ~a must have at least one identifier set in its members." jtm-list))))
    (let* ((top (make-construct 'TopicC :start-revision revision
				:psis t-psis
				:item-identifiers t-iis
				:locators t-sls)))
      (dolist (tm local-parents)
	(add-to-tm tm top))
      top)))


(defun make-instance-of-association (instance-top type-top parents &key
				     (revision *TM-REVISION*))
  "Creates and returns a type-instance-association for the passed
   instance and type topics."
  (declare (TopicC instance-top type-top)
	   (List parents)
	   (Integer revision))
  (let ((t-top (get-item-by-psi *type-psi* :revision revision))
	(i-top (get-item-by-psi *instance-psi* :revision revision))
	(ti-top (get-item-by-psi *type-instance-psi* :revision revision)))
    (let ((assoc (make-construct 'AssociationC :start-revision revision
				 :instance-of ti-top
				 :roles (list (list :start-revision revision
						    :player instance-top
						    :instance-of i-top)
					      (list :start-revision revision
						    :player type-top
						    :instance-of t-top)))))
      (dolist (tm parents)
	(add-to-tm tm assoc))
      assoc)))


(defun merge-topics-from-jtm-lists (jtm-lists parents &key (instance-of-p t)
				    (revision *TM-REVISION*) prefixes)
  "Creates and returns a list of topics."
  (declare (List jtm-lists parents prefixes)
	   (Boolean instance-of-p)
	   (Integer revision))
  (map 'list #'(lambda(jtm-list)
		 (merge-topic-from-jtm-list
		  jtm-list parents :revision revision :prefixes prefixes
		  :instance-of-p instance-of-p))
       jtm-lists))


(defun merge-topic-from-jtm-list(jtm-list parents &key (instance-of-p t)
				  (revision *TM-REVISION*) prefixes)
  "Creates and returns a topic object from the passed jtm
   list generated by json:decode-json-from-string."
  (declare (List jtm-list prefixes parents)
	   (Boolean instance-of-p)
	   (Integer revision))
  (let* ((ids (append (get-item :ITEM--IDENTIFIERS jtm-list)
		      (get-item :SUBJECT--IDENTIFIERS jtm-list)
		      (get-item :SUBJECT--LOCATORS jtm-list)))
	 (top (when ids
		(get-item-from-jtm-reference (first ids) :revision revision
					     :prefixes prefixes)))
	 (instanceof (get-items-from-jtm-references
		      (get-item :INSTANCE--OF jtm-list) :revision revision
		      :prefixes prefixes))
	 (top-names (import-characteristics-from-jtm-lists
		     (get-item :NAMES jtm-list) top
		     #'import-name-from-jtm-list :revision revision
		     :prefixes prefixes))
	 (top-occs (import-characteristics-from-jtm-lists
		    (get-item :OCCURRENCES jtm-list) top
		    #'import-occurrence-from-jtm-list :revision revision
		    :prefixes prefixes)))
    (unless ids
      (error (make-condition 'JTM-error :message (format nil "From merge-topic-from-jtm-list(): the passed topic has to own at least one identifier: ~a" jtm-list))))
    (unless top
      (error (make-condition 'JTM-error :message (format nil "From merge-topic-from-jtm-list(): cannot find a topic that matches the corresponding JTM-list: ~a" jtm-list))))
    (when (and (not instance-of-p) instanceof)
      (error (make-condition 'JTM-error :message (format nil "From merge-topic-from-jtm-list(): the JTM-topic has an instance_of member set, but JTM version 1.0 does not allow an intance_of member within a topic object: ~a" jtm-list))))
    (dolist (type-top instanceof)
      (make-instance-of-association top type-top parents :revision revision))
    (dolist (name top-names)
      (add-name top name :revision revision))
    (dolist (occ top-occs)
      (add-occurrence top occ :revision revision))
    top))


(defun import-name-from-jtm-list (jtm-list parent &key
				  (revision *TM-REVISION*) prefixes)
  "Creates and returns a name object from the passed jtm
   list generated by json:decode-json-from-string."
  (declare (List jtm-list prefixes)
	   (Integer revision)
	   (type (or Null TopicC) parent))
  (let* ((iis (import-identifiers-from-jtm-strings
	       (get-item :ITEM--IDENTIFIERS jtm-list)
	       :prefixes prefixes))
	 (scope (get-item :SCOPE jtm-list))
	 (type (get-item :TYPE jtm-list))
	 (value (get-item :VALUE jtm-list))
	 (name-variants (get-item :VARIANTS jtm-list))
	 (reifier (get-item :REIFIER jtm-list))
	 (parent-references (get-item :PARENT jtm-list))
	 (local-parent
	  (if parent
	      (list parent)
	      (when parent-references
		(get-items-from-jtm-references
		 parent-references :revision revision :prefixes prefixes)))))
    (when (/= (length local-parent) 1)
      (error (make-condition 'JTM-error :message (format nil "From import-name-from-jtm-string(): the JTM name ~a must have exactly one parent set in its members." jtm-list))))
    (let ((name
	   (make-construct
	    'NameC :start-revision revision
	    :item-identifiers iis
	    :charvalue value
	    :themes (get-items-from-jtm-references
		     scope :revision revision :prefixes prefixes)
	    :instance-of (when type
			   (get-item-from-jtm-reference
			    type :revision revision :prefixes prefixes))
	    :parent (first local-parent)
	    :reifier (when reifier
		       (get-item-from-jtm-reference
			reifier :revision revision :prefixes prefixes)))))
      (import-characteristics-from-jtm-lists name-variants name
					     #'import-variant-from-jtm-list
					     :revision revision :prefixes prefixes)
      name)))


(defun import-occurrence-from-jtm-list (jtm-list parent &key
					(revision *TM-REVISION*) prefixes)
  "Creates and returns an occurrence object from the passed jtm
   list generated by json:decode-json-from-string."
  (declare (List jtm-list prefixes)
	   (Integer revision)
	   (type (or Null TopicC) parent))
  (let* ((iis (import-identifiers-from-jtm-strings
	       (get-item :ITEM--IDENTIFIERS jtm-list)
	       :prefixes prefixes))
	 (datatype (get-item :DATATYPE jtm-list))
	 (scope (get-item :SCOPE jtm-list))
	 (type (get-item :TYPE jtm-list))
	 (value (get-item :VALUE jtm-list))
	 (reifier (get-item :REIFIER jtm-list))
	 (parent-references (get-item :PARENT jtm-list))
	 (local-parent
	  (if parent
	      (list parent)
	      (when parent-references
		(get-items-from-jtm-references
		 parent-references :revision revision :prefixes prefixes)))))
    (when (/= (length local-parent) 1)
      (error (make-condition 'JTM-error :message (format nil "From import-occurrence-from-jtm-string(): the JTM occurrence ~a must have a parent set in its members." jtm-list))))
    (unless type
      (error (make-condition 'JTM-error :message (format nil "From import-occurrence-from-jtm-string(): the JTM occurrence ~a must have a type set in its members." jtm-list))))
    (make-construct 'OccurrenceC :start-revision revision
		    :item-identifiers iis
		    :datatype (if datatype datatype *xml-string*)
		    :charvalue value
		    :themes (get-items-from-jtm-references
			     scope :revision revision :prefixes prefixes)
		    :instance-of (get-item-from-jtm-reference
				  type :revision revision :prefixes prefixes)
		    :parent (first local-parent)
		    :reifier (when reifier
			       (get-item-from-jtm-reference
				reifier :revision revision :prefixes prefixes)))))


(defun import-characteristics-from-jtm-lists(jtm-lists parent next-fun &key
					     (revision *TM-REVISION*) prefixes)
  "Creates and returns a list of TM-Constructs returned by next-fun."
  (declare (List jtm-lists prefixes)
	   (Integer revision)
	   (type (or Null ReifiableConstructC) parent)
	   (Function next-fun))
  (map 'list #'(lambda(jtm-list)
		 (apply next-fun (list jtm-list parent :revision revision
				       :prefixes prefixes)))
       jtm-lists))


(defun import-variant-from-jtm-list(jtm-list parent &key
				      (revision *TM-REVISION*) prefixes)
  "Creates a variant object from the passed jtm list generated by
   json:decode-json-from-string."
  (declare (List jtm-list prefixes)
	   (type (or Null NameC) parent)
	   (Integer revision))
  (let* ((iis (import-identifiers-from-jtm-strings
	       (get-item :ITEM--IDENTIFIERS jtm-list)
	       :prefixes prefixes))
	 (datatype (get-item :DATATYPE jtm-list))
	 (scope (get-item :SCOPE jtm-list))
	 (value (get-item :VALUE jtm-list))
	 (reifier (get-item :REIFIER jtm-list))
	 (parent-references (get-item :PARENT jtm-list))
	 (local-parent
	  (if parent
	      (list parent)
	      (when parent-references
		(get-items-from-jtm-references
		 parent-references :revision revision :prefixes prefixes)))))
    (when (/= (length local-parent) 1)
      (error (make-condition 'JTM-error :message (format nil "From import-variant-from-jtm-string(): the JTM variant ~a must have exactly one parent set in its members." jtm-list))))
    (make-construct 'VariantC :start-revision revision
		    :item-identifiers iis
		    :datatype (if datatype datatype *xml-string*)
		    :charvalue value
		    :themes (get-items-from-jtm-references
			     scope :revision revision :prefixes prefixes)
		    :parent (first local-parent)
		    :reifier (when reifier
			       (get-item-from-jtm-reference
				reifier :revision revision :prefixes prefixes)))))


(defun import-identifiers-from-jtm-strings
    (jtm-strings  &key (identifier-type-symbol 'ItemIdentifierC) prefixes)
  "Creates and returns a list of identifiers specified by jtm-strings and
   identifier-type-symbol."
  (declare (List jtm-strings)
	   (Symbol identifier-type-symbol)
	   (List prefixes))
  (map 'list #'(lambda(jtm-string)
		 (import-identifier-from-jtm-string
		  jtm-string :prefixes prefixes
		  :identifier-type-symbol identifier-type-symbol))
       jtm-strings))


(defun import-identifier-from-jtm-string
    (jtm-string &key (identifier-type-symbol 'ItemIdentifierC) prefixes)
  "Creates and returns an identifier of the type specified by
   identifier-type-symbol."
  (declare (String jtm-string)
	   (Symbol identifier-type-symbol)
	   (List prefixes))
  (let ((uri-value (compute-uri-from-jtm-identifier jtm-string prefixes)))
    (make-construct identifier-type-symbol
		    :uri uri-value)))
  


(defun get-item-from-jtm-reference (reference-string &key (revision *TM-REVISION*)
				    prefixes)
  "Returns a ReifiableConstructC that is bound to the reference that is
   passed to this function. If the construct cannot be found the error
   tm-reference-error is thrown."
  (declare (Integer revision)
	   (List prefixes)
	   (String reference-string))
  (let* ((identifier-type
	  (get-identifier-type-from-jtm-reference reference-string))
	 (identifier-value (subseq reference-string 3))
	 (identifier-uri
	  (compute-uri-from-jtm-identifier identifier-value prefixes))
	 (construct
	  (d::get-item-by-identifier identifier-uri :revision revision
				     :identifier-type-symbol identifier-type)))
    (if construct
	construct
	(error (make-condition 'missing-reference-error :message (format nil "From get-item-from-jtm-reference(): cannot find the item identified by \"~a\"(~a)" identifier-uri reference-string)
			       :reference identifier-uri)))))	


(defun get-items-from-jtm-references (reference-strings &key (revision *TM-REVISion*)
				      prefixes)
  "Returns a list of ReifiableConstructCs that are referenced via the
   string-values in reference-strings."
  (declare (List reference-strings prefixes)
	   (Integer revision))
  (map 'list #'(lambda(reference-string)
		 (get-item-from-jtm-reference reference-string :revision revision
					      :prefixes prefixes))
       reference-strings))


(defun compute-uri-from-jtm-identifier (identifier-value prefixes)
  "Returns the full uri of an identifier string, i.e.
   * if the value is of the form '[pref:value]' the return value is
     the concatenation of 'value-of-pref' and 'value'.
   * if the value is of the form 'full-uri' the return value is
     'full-uri'"
  (declare (String identifier-value)
	   (List prefixes))
  (cond ((and (string-starts-with identifier-value "[")
	      (string-ends-with identifier-value "]"))
	 (let* ((pref-name
		 (let ((value (string-until identifier-value ":")))
		   (when value
		     (subseq value 1))))
		(suffix
		 (when pref-name
		   (let ((value
			  (subseq identifier-value (1+ (length pref-name)))))
		     (when value
		       (subseq value (min 1 (length value))
			       (max 0 (1- (length value)))))))))
	   (when (or (not pref-name) (not suffix))
	     (error (make-condition 'JTM-error :message (format nil "From compute-uri-from-jtm-identifier: the section within the range of \"[\" and \"]\" must be of the form prefix:suffix, but is: \"~a\"" identifier-value))))
	   (compute-full-uri prefixes pref-name suffix)))
	((> (length identifier-value) 0)
	 identifier-value)
	(t
	 (error (make-condition 'JTM-error :message (format nil "From compute-uri-from-jtm-identifier(): the identifier-value must be of the form \"[pref:value]\" or \"full-uri\", but is: \"~a\"" identifier-value))))))


(defun get-identifier-type-from-jtm-reference (identifier-string)
  "Returns the symbol 'PersistentIdC if identifier-string starts
   with si:, 'SubjectLocatorC if identifier-string starts with
   sl:, or 'ItemIdentifierC if identifier-string starts with ii:.
   If identifier-string do not start with one of these strings
   the error JTM-error is thrown."
  (cond ((string-starts-with identifier-string "ii:")
	 'ItemIdentifierC)
	((string-starts-with identifier-string "si:")
	 'PersistentIdC)
	((string-starts-with identifier-string "sl:")
	 'SubjectLocatorC)
	(t
	 (error (make-condition 'JTM-error :message (format nil "From get-identifier-type(): the identifier value must start with one of \"ii:\", \"si:\", or \"sl:\", but is: \"~a\"" identifier-string))))))