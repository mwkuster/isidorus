;;+-----------------------------------------------------------------------------
;;+  Isidorus
;;+  (c) 2008-2010 Marc Kuester, Christoph Ludwig, Lukas Georgieff
;;+
;;+  Isidorus is freely distributable under the LLGPL license.
;;+  You can find a detailed description in trunk/docs/LLGPL-LICENSE.txt and
;;+  trunk/docs/LGPL-LICENSE.txt.
;;+-----------------------------------------------------------------------------


(in-package :jtm)

;TODO: write a generic outer method that evaluates the item_type,
;      version, parent, and prefixes and finally calls a special
;      function that creates a construct


(defun get-item (item-keyword jtm-list)
  (declare (Keyword item-keyword)
	   (List jtm-list))
  (rest (find item-keyword jtm-list :key #'first)))


(defun import-name-from-jtm-list (jtm-list parent &key
				  (revision *TM-REVISION*) prefixes)
  "Creates and returns a name object from the passed jtm
   list generated by json:decode-json-from-string."
  (declare (List jtm-list prefixes)
	   (Integer revision)
	   (type (or Null TopicC) parent))
  (let* ((iis (import-identifiers-from-jtm-strings
	       (get-item :ITEM--IDENTIFIERS jtm-list)
	       :prefixes prefixes))
	 (scope (get-item :SCOPE jtm-list))
	 (type (get-item :SCOPE jtm-list))
	 (value (get-item :VALUE jtm-list))
	 (name-variants (get-item :VARIANTS jtm-list))
	 (reifier (get-item :REIFIER jtm-list))
	 (parent-references (get-item :PARENT jtm-list))
	 (local-parent
	  (if parent
	      (list parent)
	      (when parent-references
		(get-items-from-jtm-references
		 parent-references :revision revision :prefixes prefixes)))))
    (unless local-parent
      (error (make-condition 'JTM-error :message (format nil "From import-occurrence-from-jtm-string(): the JTM occurrence ~a must have a parent set in its members." jtm-list))))
    (unless type
      (error (make-condition 'JTM-error :message (format nil "From import-occurrence-from-jtm-string(): the JTM occurrence ~a must have a type set in its members." jtm-list))))
    (let ((name
	   (make-construct
	    'NameC :start-revision revision
	    :item-identifiers iis
	    :value (if value value "")
	    :themes (get-items-from-jtm-references
		     scope :revision revision :prefixes prefixes)
	    :instance-of (get-item-from-jtm-reference
			  type :revision revision :prefixes prefixes)
	    :parent local-parent
	    :reifier (when reifier
		       (get-item-from-jtm-reference
			reifier :revision revision :prefixes prefixes)))))
      (import-constructs-from-jtm-lists name-variants name
					#'import-variant-from-jtm-list
					:revision revision :prefixes prefixes)
      name)))


(defun import-occurrence-from-jtm-list (jtm-list parent &key
					(revision *TM-REVISION*) prefixes)
  "Creates and returns an occurrence object from the passed jtm
   list generated by json:decode-json-from-string."
  (declare (List jtm-list prefixes)
	   (Integer revision)
	   (type (or Null OccurrenceC) parent))
  (let* ((iis (import-identifiers-from-jtm-strings
	       (get-item :ITEM--IDENTIFIERS jtm-list)
	       :prefixes prefixes))
	 (datatype (get-item :DATATYPE jtm-list))
	 (scope (get-item :SCOPE jtm-list))
	 (type (get-item :SCOPE jtm-list))
	 (value (get-item :VALUE jtm-list))
	 (reifier (get-item :REIFIER jtm-list))
	 (parent-references (get-item :PARENT jtm-list))
	 (local-parent
	  (if parent
	      (list parent)
	      (when parent-references
		(get-items-from-jtm-references
		 parent-references :revision revision :prefixes prefixes)))))
    (unless local-parent
      (error (make-condition 'JTM-error :message (format nil "From import-occurrence-from-jtm-string(): the JTM occurrence ~a must have a parent set in its members." jtm-list))))
    (unless type
      (error (make-condition 'JTM-error :message (format nil "From import-occurrence-from-jtm-string(): the JTM occurrence ~a must have a type set in its members." jtm-list))))
    (make-construct 'OccurrenceC :start-revision revision
		    :item-identifiers iis
		    :datatype (if datatype datatype *xml-string*)
		    :value (if value value "")
		    :themes (get-items-from-jtm-references
			     scope :revision revision :prefixes prefixes)
		    :instance-of (get-item-from-jtm-reference
				  type :revision revision :prefixes prefixes)
		    :parent local-parent
		    :reifier (when reifier
			       (get-item-from-jtm-reference
				reifier :revision revision :prefixes prefixes)))))


(defun import-constructs-from-jtm-lists(jtm-lists parent next-fun &key
					(revision *TM-REVISION*) prefixes)
  "Creates and returns a list of TM-Constructs returned by next-fun."
  (declare (List jtm-lists prefixes)
	   (Integer revision)
	   (type (or Null NameC) parent)
	   (Function next-fun))
  (map 'list #'(lambda(jtm-list)
		 (apply next-fun (list jtm-list parent :revision revision
				       :prefixes prefixes)))
       jtm-lists))


(defun import-variant-from-jtm-list(jtm-list parent &key
				      (revision *TM-REVISION*) prefixes)
  "Creates a variant object from the passed jtm list generated by
   json:decode-json-from-string."
  (declare (List jtm-list prefixes)
	   (type (or Null NameC) parent)
	   (Integer revision))
  (let* ((iis (import-identifiers-from-jtm-strings
	       (get-item :ITEM--IDENTIFIERS jtm-list)
	       :prefixes prefixes))
	 (datatype (get-item :DATATYPE jtm-list))
	 (scope (get-item :SCOPE jtm-list))
	 (value (get-item :VALUE jtm-list))
	 (reifier (get-item :REIFIER jtm-list))
	 (parent-references (get-item :PARENT jtm-list))
	 (local-parent
	  (if parent
	      (list parent)
	      (when parent-references
		(get-items-from-jtm-references
		 parent-references :revision revision :prefixes prefixes)))))
    (unless local-parent
      (error (make-condition 'JTM-error :message (format nil "From import-variant-from-jtm-string(): the JTM variant ~a must have a parent set in its members." jtm-list))))
    (make-construct 'VariantC :start-revision revision
		    :item-identifiers iis
		    :datatype (if datatype datatype *xml-string*)
		    :value (if value value "")
		    :themes (get-items-from-jtm-references
			     scope :revision revision :prefixes prefixes)
		    :parent local-parent
		    :reifier (when reifier
			       (get-item-from-jtm-reference
				reifier :revision revision :prefixes prefixes)))))


(defun import-identifiers-from-jtm-strings
    (jtm-strings  &key (identifier-type-symbol 'ItemIdentifeirC) prefixes)
  "Creates and returns a list of identifiers specified by jtm-strings and
   identifier-type-symbol."
  (declare (List jtm-strings)
	   (Symbol identifier-type-symbol)
	   (List prefixes))
  (map 'list #'(lambda(jtm-string)
		 (import-identifier-from-jtm-string
		  jtm-string identifier-type-symbol :prefixes prefixes))
       jtm-strings))

(defun import-identifier-from-jtm-string(jtm-string identifier-type-symbol
					 &key prefixes)
  "Creates and returns an identifier of the type specified by
   identifier-type-symbol."
  (declare (String jtm-string)
	   (Symbol identifier-type-symbol)
	   (List prefixes))
  (let ((uri-value (compute-uri-from-jtm-identifier jtm-string prefixes)))
    (make-construct identifier-type-symbol
		    :uri uri-value)))
  


(defun get-item-from-jtm-reference (reference-string &key (revision *TM-REVISION*)
				    prefixes)
  "Returns a ReifiableConstructC that is bound to the reference that is
   passed to this function. If the construct cannot be found the error
   tm-reference-error is thrown."
  (declare (Integer revision)
	   (List prefixes)
	   (String reference-string))
  (let* ((identifier-type
	  (get-identifier-type-from-jtm-reference reference-string))
	 (identifier-value (subseq reference-string 3))
	 (identifier-uri
	  (compute-uri-from-jtm-identifier identifier-value prefixes))
	 (construct
	  (d::get-item-by-identifier identifier-uri :revision revision
				     :identifier-type-symbol identifier-type)))
    (if construct
	construct
	(error (make-condition 'missing-reference-error :message (format nil "From get-item-from-jtm-reference(): cannot find the item identified by \"~a\"(~a)" identifier-uri reference-string)
			       :reference identifier-uri)))))	


(defun get-items-from-jtm-references (reference-strings &key (revision *TM-REVISion*)
				      prefixes)
  "Returns a list of ReifiableConstructCs that are referenced via the
   string-values in reference-strings."
  (declare (List reference-strings prefixes)
	   (Integer revision))
  (map 'list #'(lambda(reference-string)
		 (get-item-from-jtm-reference reference-string :revision revision
					      :prefixes prefixes))
       reference-strings))


(defun compute-uri-from-jtm-identifier (identifier-value prefixes)
  "Returns the full uri of an identifier string, i.e.
   * if the value is of the form '[pref:value]' the return value is
     the concatenation of 'value-of-pref' and 'value'.
   * if the value is of the form 'full-uri' the return value is
     'full-uri'"
  (declare (String identifier-value)
	   (List prefixes))
  (cond ((and (string-starts-with identifier-value "[")
	      (string-ends-with identifier-value "]"))
	 (let* ((pref-name
		 (let ((value (string-until identifier-value ":")))
		   (when value
		     (subseq value 1))))
		(suffix
		 (when pref-name
		   (let ((value
			  (subseq identifier-value (1+ (length pref-name)))))
		     (when value
		       (subseq value (min 1 (length value))
			       (max 0 (1- (length value)))))))))
	   (when (or (not pref-name) (not suffix))
	     (error (make-condition 'JTM-error :message (format nil "From compute-uri-from-jtm-identifier: the section within the range of \"[\" and \"]\" must be of the form prefix:suffix, but is: \"~a\"" identifier-value))))
	   (compute-full-uri prefixes pref-name suffix)))
	((> (length identifier-value) 0)
	 identifier-value)
	(t
	 (error (make-condition 'JTM-error :message (format nil "From compute-uri-from-jtm-identifier(): the identifier-value must be of the form \"[pref:value]\" or \"full-uri\", but is: \"~a\"" identifier-value))))))


(defun get-identifier-type-from-jtm-reference (identifier-string)
  "Returns the symbol 'PersistentIdC if identifier-string starts
   with si:, 'SubjectLocatorC if identifier-string starts with
   sl:, or 'ItemIdentifierC if identifier-string starts with ii:.
   If identifier-string do not start with one of these strings
   the error JTM-error is thrown."
  (cond ((string-starts-with identifier-string "ii:")
	 'ItemIdentifierC)
	((string-starts-with identifier-string "si:")
	 'PersistentIdC)
	((string-starts-with identifier-string "sl:")
	 'SubjectLocatorC)
	(t
	 (error (make-condition 'JTM-error :message (format nil "From get-identifier-type(): the identifier value must start with one of \"ii:\", \"si:\", or \"sl:\", but is: \"~a\"" identifier-string))))))